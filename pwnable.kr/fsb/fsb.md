# 풀이과정

![카드](https://user-images.githubusercontent.com/67177785/141669202-0a53f327-a07b-4ec9-9e86-cc4d0ae4aff7.PNG)

포맷 스트링으로 실행흐름을 조작하는 문제다

![파일](https://user-images.githubusercontent.com/67177785/141669265-df92e221-5ae9-4bc2-9a6e-7736a5e1879f.PNG)

카드에 나온 경로로 접속하면 이렇게 플래그, 실행파일, 소스코드가 제공되는데

플래그는 읽기 권한이 없으므로 실행파일을 통해서만 볼 수 있다.

그러니까 실행파일의 실행흐름을 조작해 쉘을 따내야(/bin/sh가 프로그램 안에서 실행되어야) 플래그를 보여준다.

![실행모습](https://user-images.githubusercontent.com/67177785/141669785-9d2bf9db-1b1b-4a08-b7ad-be72584f58e9.PNG)

먼저 저 fsb를 실행해보면 문자열을 입력받고 출력하기를 4번 반복하고

키 값을 때려 맞추라고 한다. 키가 맞아야 통과인것 같다.

취약점을 분석하기 위해 소스코드를 보자

![소스코드](https://user-images.githubusercontent.com/67177785/141669812-bc2a6515-12f4-45bf-acbf-5cac3e018f5e.PNG)

키 값은 랜덤이라 알 수 없지만

입력한 문자열을 printf를 통해 그대로 출력하는 모습이다

그럼 저 부분을 공격하면 되는 것 같은데

바이너리를 다운받아 분석해보면

![main프로시저](https://user-images.githubusercontent.com/67177785/141677133-2ec85fe3-4c40-401a-b0f1-a82941abfdb1.PNG)

키 변수의 주소는 0x804a060으로 고정되어 있음을 확인할 수 있었다.

주소값이 고정되어 있으므로 키 변수에 접근해 값을 조작할 수 있을것이다.

하지만 키 변수에 접근할 때 문제점이 하나 있는데

입력을 받는 버퍼는 전역변수로서 스택에 존재하지 않는다.

그 말은 %n의 목적지가 되어줄 주소값을 버퍼에서 참조할 수 없고

주소를 설정해주기 까다로워진다는 말이다.

문제를 해결하기 위해 fsb함수 내부 변수들을 유심히 잘 봤는데

pargv와 penvp가 눈에 띄었다.

이 두 변수는 문자열을 입력받기 전에 사용자가 입력한 명령행 인자를 0으로 초기화 하는데 사용된다.

그런데 초기화가 끝나도 pargv와 penvp안에는 두 매개변수 argv와 envp의 주소값이 그대로 남아있다.

<img src="https://user-images.githubusercontent.com/67177785/141677747-f796c07e-efa8-4b2d-a811-0592b2546095.png" height="700px"/>

**[printf 호출 직후 스택]**

이를 이용해 스택에서 argv와 envp의 주소로 값을 덮어쓸수 있다

key의 주소는 0x804a060 고정이므로 pargv값을 %n으로 참조해 key 주소값(0x804a060)을 argv에 덮어쓴 뒤

argv값을 %n으로 참조해 key값을 마음대로 바꾸면 완벽

fsb함수에서 처음에 스택을 0x48만큼 할당하고

pargv는 ebp-0x10 고정이니까 스택 최상단 기준 오프셋은 0x38(=56)

여기서 문자열 주소값의 크기를 빼면 54,

4로 나누면 13, %x를 13번 하고 %n을 넣어주면 argv를 조작할 수 있다

마찬가지로 argv는 fsb의 스택 프레임 바로 밑에 위치하니까

스택 최상단으로 부터의 오프셋은 0x48 + 8 = 0x50(=80),

문자열 주소값의 크기를 빼면 76, 4로 나누면 19니까

%x를 19번해서 접근한 뒤 %n해주면 최종적으로 키 값을 덮어쓰게 된다

키 변수는 8바이트, 공격 2번에 4바이트씩 수정할 수 있고 공격 기회는 총 4번이 주어지니까

키 변수는 상위 4바이트, 하위 4바이트로 나누어 각각 수정하면 키 검증을 통과 할 수 있을거라 생각했지만

쉘을 그리 쉽게 내어주지는 않았다.

```asm
call strtoull
mov edx, eax
sar edx, 1fh
mov [ebp-0x30], eax
mov [ebp-0x2c], edx
```

이런식으로 공격이 끝나고 키 값을 입력받을 때 상위 4바이트를 하위 4바이트의 부호에 따라 양수면 0, 음수면 FFFFFFFF로 설정하는 것이다.

그래서 키 값의 상위 4바이트도 0또는 FFFFFFFF로 설정해야 하는데

이 값은 %n으로 설정할 수 없는 값이다

그러면 이 상황에서 상위 4바이트를 저렇게 만드려면 2번으로 나눠서 덮어씌우면 되는데

그럼 상위 4바이트를 만드는데 2번, 하위 4바이트를 만드는데 1번의 기회가 필요하다.

위에서 다룬 시나리오대로면 키 값을 한번 덮어씌우는데 공격 기회가 2번 필요하니까

주어진 4번의 기회 안에서 저 조건을 만족하도록 키 값을 조작하는게 불가능함

근데 생각을 해보니 pargv, penvp 두개를 준 이유가 있을것 같다

그럼 만약에 argv에 0x804a064, envp에 0x804a060을 넣고 

두 개를 동시에 %n으로 참조해준다면?

8바이트의 키 변수 하나를 온전히 조작하면서 공격 기회를 하나 아낄수 있다.

그리고 만약에 pargv와 penvp를 %n으로 동시에 참조해준다면?

argv와 envp 두 개를 온전히 조작하면서 공격 기회를 하나 더 아끼게 된다.

그럼 공격 2번만에 키 변수를

```
?? 00 00 00 ?? 00 00 00
```

이렇게 바꾸고 나머지 공격 2번만에 저 5번째 바이트를 0으로 바꿀 수 있게된다.

위의 아이디어를 기반으로 페이로드를 짜보면

```python
payload1 = '%8x' * 12 + '%134520832x%nAAAA%n'
payload2 = '%8x' * 19 + '%n'
payload3 = '%8x' * 12 + '%134520833x%n' + 'AAAAAAAAAAAAAAAAAAAAA'
payload4 = '%8x' * 19 + '%n'
key = 39064
```

1. argv=0x804a060, envp=0x804a064로 동시에 설정하고
2. argv와 envp를 참조해 키 변수를 이렇게 조작하고
```
98 00 00 00 98 00 00 00
```
3. argv=0x804a061로 덮어쓰고
4. %n으로 상위 4바이트를 0으로 만들면 끝!

참고로 세번째 페이로드에서 AAAAA는 read함수가 입력값을 읽어들일때 끝을 null로 안끝내줘서 붙여넣은거임

어쨌든 저대로 페이로드를 전송하면

![정답](https://user-images.githubusercontent.com/67177785/141687614-238b932c-ee1d-4812-814f-497ce05702bf.PNG)

플래그를 보여준다

flag : Have you ever saw an example of utilizing [n] format character?? :(

# 비하인드

## 삽질#1

아니 근데 문자열 입력제한이 100바이트인데 0x804a060같은 길이를 어떻게 출력하니?

문제가 말이 안된다

근데 말이 안되던건 나였지

%10000d처럼 쓰면 숫자포함 출력 길이를 10000으로 만들수 있으니까

## 삽질#2

fsb 프로시저에서 처음에 스택을 0x48만큼 할당하고

pargv는 ebp-0x10 위치 고정이니까 스택 최상단 기준 오프셋은 0x38(=56)

4로 나누면 14, %x를 14번 하고 %n 넣어주면 argv값을 조작할 수 있겠네~

ㅇㅋ 그럼 한번 해봅시다

```
1트

pargv 주소 : 0xff838b08
argv 주소(pargv 값) : 0xff838b20
마지막으로 출력된 값 : 0xff838b20
```

??? 뭔가 오차가 있는거 같은데

내가 머리를 잘못 썼나

일단 %x 하나 빼면 해결될 문제긴 한데 어디서 실수한걸까?(여기서 한 시간 정도 고민)

아 그치

출력 문자열이 스택에 push 된다는걸 잊고 있었다

그럼 저 인자로 들어간 출력 문자열 주소값의 크기 만큼을 빼고 계산해줘야지

## pwntools 버그

재실행 할때마다 포맷 스트링 입력하는게 여간 힘든일이 아니여서 파이썬으로 자동화 해주기로 결심했다

사실 자동화 작업도 정말 신경써줘야 하는게 많이 때문에 왠만하면 안하려고 했는데 어쩔수 없다고 생각했음

그래서 페이로드 전송하고 process.recv로 출력값을 받는데 공백이 끝없이 출력된다

fsb익스플로잇 특성상 출력값 길이가 긴건 맞는데 이정도는 말이 안되지

한 3분 지나도 안끝나길래 자동화는 포기하고 Shift + Ins 복붙으로 대체함

## 삽질#3

올ㅋㅋ key 변수 절반은 조작 성공했고

나머지 절반만 바꿔주면 통과 하겠네

3번째 페이로드를

%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%134520836x%n 이렇게 쳐주면

?? segfault? 저게 잘못됬나?

아니 근데 저게 잘못됬을리가 첫번째거 복붙하고 값만 좀 수정해준건데

원래 이럴땐 무지성 디버깅이지

디버거 켜고 스택을 보면

%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%134520836x%n\nx%8x%8x%n\n

어라? \n이 2개?

아 read는 입력값 끝에 null을 안붙여주는구나

키보드로 null을 칠순 없으니까 대신에 AAAAA로 저 포맷 스트링을 덮어써주면?

잘되네

# 삽질#4

key는 잘 조작됐는데

key입력 후 검증하는 부분에서 막혔다.

아니 분명 소스코드에선 strtoull의 리턴값을 그대로 key랑 비교하는데

디버거로 분석해보니까 strtoull에서 리턴값을 pw에 저장할 때

좀 이상하게 저장함

분석해보니까 저 리턴 값을 특정한 연산을 통해 처리하는것 같은데

```asm
call strtoull
mov edx, eax
sar edx, 1fh
mov [ebp-0x30], eax
mov [ebp-0x2c], edx
```
edx에 eax값을 복사한다?

32bit에서 8바이트 값 리턴은 하위 4바이트를 eax, 상위 4바이트를 edx에 저장하는데

이건 상위 4바이트를 아예 버리겠다는 의도가 아닌가

그리고 그 밑에 sar는 찾아보니까 부호를 보존하는 쉬프트 연산이던데 

1f는 10진수로 31이고 edx 레지스터는 길이가 32bit이니까 저건 부호비트가 1이면 FFFFFFFF로,

0이면 0으로 설정하겠다는거네

그럼 키 값도 상위 4바이트는 0또는 FFFFFFFF로 설정해야 하는데

내가 지금가지 짰던 페이로드는 무슨 소용인가

## 삽질#5

키 변수 상위 4바이트를 0또는 FFFFFFFF로 만들어야 한다?

일단 %n은 출력 길이를 저장하는건데 출력 길이가 0일수는 없고 마찬가지로 -1일수는 없는데

근데 다시 생각해보니까 FFFFFFFF는 4바이트에서 부호 있는 정수로 해석하면 -1이지만

부호 없는 정수로 해석하면 4294967295로도 해석할 수 있지 않을까?

그럼 printf의 출력 길이를 4294967295로 맞추면 상위 4바이트를 FFFFFFFF로 만들 수 있을듯?

그럼 페이로드를

```python
payload4 = '%8x' * 18 + '%4294967151x' + '%n'
```

이렇게 구성하면 성공할까? 했지만 안됬고

마찬가지로 0도 mod 2^32에서 4294967296(2^32)이랑 합동이니까 출력길이를 그렇게 맞추면

0을 만들수 있지 않을까? 했지만 아예 실행해주지를 않았다

0이나 FFFFFFFF는 한번에 만들수 있는 수가 아닌 것이다

## 삽질#6

생각을 해보니 pargv와 penvp 두 개를 준 이유가 있을것 같다

그럼 만약에 argv에 0x804a060, envp에 0x804a064를 넣고 %n을 동시에 해준다면?

공격 횟수를 하나 줄여 가성비 좋게 값을 온전히 덮어쓸 수 있다

아 이렇게 공격 기회를 더 확보 할 수 있구나

근데 아직 부족하다

기회가 하나 더 필요하다

그럼 여기서 또 횟수를 한 번 더 줄이려면?

pargv나 penvp같은 값이 스택에 하나 더 있으면 된다

근데 소스코드를 봐도

![printf 직전 스택](https://user-images.githubusercontent.com/67177785/141692290-ec337024-b68f-4c35-b553-656327a5dd9e.PNG)

디버거로 스택을 확인해도 쓸만한 값이 보이지 않는다

100바이트 입력제한 덕에 접근 가능한 스택 메모리 범위에도 한계가 있으니

바로 보이는 fffbd744, fffbefe0 같은건 쓰지 못한다

제한이 없어도 저 값들은 사용자가 명령행에서 입력한 문자열 인자의 주소값이니(소스코드 참조) 오프셋도 실행할 때마다 바뀐다

머리가 아프다. 막다른 길이다

그러니까 이렇게 하지 말고 다른 길을 찾아서 풀어야 하는 것이다

# 느낀점

문제 푸는 시간보다 writeup 작성작업이 더 오래걸림

이제 이거 진로 세특 제출용으로 말투 바꾸고 단어선택 바꿔서 하나 더 만들어야 하는데

그래도 쓰는게 보람이 있어서 계속 한다

이것도 다 기록이니까