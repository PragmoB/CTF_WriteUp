# 풀이과정

일단 기승전실행

바이너리를 2번 입력받는다

다운받고 edb로 분석

![디스어셈main](https://user-images.githubusercontent.com/67177785/130820820-fbf97de1-742e-4f72-9b30-e6e8f0caeb1e.PNG)

입력받은 바이너리를 run하는 것을 확인 할 수 있다

저게 핵심인듯 자세히 들어가보면

각각의 바이트에 대해서 연산을 처리하는데

분석결과는 이렇게 된다

```C
case 0xc9 :
  
  // 의미를 모르겠는 부동소수점 연산 진행?
  // 연산결과를 0x404010번지에 저장
  break;
case 0x55 :

  // 0x404010번지에서 값에서 8을 뺴고
  // 그 번지에 다음 바이트를 저장
  break;
case 0x5d :

  // 0x404010번지 값에 8더하기
  break;

case 0x01 :

  // 0x404010번지 값 번지의 값을 다음 바이트를 length로 해서 화면에 출력
  break;
case 0x02 :

  // 다음 바이트를 length로 해서 문자열을 입력받고 0x404010번지 값 번지에 저장
  break;
```

어디서 많이 봤던 문제인데ㅋㅋ

pwnable.kr에 brain fuck이 생각나는 문제

그때 기억을 되살려보면

GOT의 특정 api 주소를 출력해서 libc base를 구하고

저 명령어들을 조합해서 GOT를 조작하고 쉘을 땄었음

마침 GOT가 근처에 있으니까 봤는데 세상에..

GOT는 쓰기 권한이 없다

그럼 어떻게 실행흐름을 바꿀 수 있단 말인가?

사실 짐작은 갔다.

프로시저 끝부분에서 free함수를 호출하는데

여기에 답이 있을 삘이긴 했음

리눅스에 무지한 탓에 내가 몰랐던게 있는데

리눅스에서 malloc과 free는 각각 __malloc_hook과 __free_hook이라는 영역에 주소값을 입력해서 후킹할 수 있다.

그러니까 첫번째 run에 info leak하고 두번째 run에서 __free_hook을 info leak으로 얻어낸 system주소로 조작하면

마지막에 free대신에 system을 호출하게 된다

구현은 exploit.py에 해놨다

대회 당일날 문제 풀 때 이걸 몰라서ㅠㅠ info leak까지만 성공하고 막상 쉘은 따내지 못했다

반쪽짜리 성공

# 비하인드

사실 c9는 404010번지에 다음 8개의 문자를 덮어씌우는 분기였다

'\xc9\x12\x34\x56\x78\xde\xad\xbe\xef'을 run에 넣는다 하면 

404010번지에 값이 12 34 56 78 de ad be ef 로 기록됨

대회 끝나고 다른 참가자분들 write up 읽으면서 알게된 사실이다

어셈블리를 분석하지 말고 결과값만 관찰했다면 캐치할 수 있었을텐데

후회된다 대회 당일날 저거 분석하느라 시간 엄청 썼는데

